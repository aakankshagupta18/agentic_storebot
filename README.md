# StoreBot â€” Multiâ€‘Agent Chatbot (Router + Data Access + Customer Success + HR)

A productionâ€‘ready, KGâ€‘driven chatbot that routes user requests to specialized agents:

* **Data Access Agent** â€” turns questions into **one executable PostgreSQL query** using your Knowledge Graph (KG) JSON, executes it, and selfâ€‘repairs once on error.
* **Customer Success Agent** â€” places/updates/cancels orders and accepts eligible returns via **DB writes** with an explicit **confirm** gate.
* **Human Resources Agent** â€” navigates org hierarchy (regional/state/segment/category managers), drafts escalation emails, and (optionally) sends them via your notifier.
* **Router** â€” classifies messages into `data_access`, `customer_success`, `hr` (or a safe fallback) and orchestrates multiâ€‘step flows (e.g., askâ†’confirm for writes).

> **Data source contract:** Agents may only use schemas/tables/columns defined by the **Knowledge Graph JSON**. No hallucinated objects.

---

## âœ¨ Features

* **Singleâ€‘statement SQL** (SELECT/WITH) generated by the LLM; no JSON plans required.
* **PostgreSQL only** (safe read path for Data Access; write path gated in Customer Success).
* **Light normalization** prevents trivial quoting/tableâ€‘basename issues.
* **Selfâ€‘repair:** On DB error, the agent uses the exact Postgres error to produce a corrected SQL once.
* **Write safety:** All writes are previewed and blocked until the user replies `confirm`.
* **Org-aware HR flows:** Resolves managers from KG tables; drafts crisp escalation emails.

---

## ğŸ—‚ï¸ Repository Layout (key files)

```
agents/
  data_access.py        # SQL-only, KG-driven query agent (SELECT/WITH + self-repair)
  customer_success.py   # Write agent (INSERT/UPDATE/DELETE) with 'confirm' gate
  hr.py                 # HR agent: org lookup + escalation drafts (+optional send)
  router.py             # Intent routing, confirmation state, and orchestration

app.py                  # FastAPI app exposing POST /chat
query/
  federation.py         # run_sql(), summarize(), and DB engine wiring

graph/
  graph_store.py        # Loads KG and exposes table/column metadata + join hints

/mnt/data/store_graph.json  # Your Knowledge Graph JSON (path configurable)
```

---

## ğŸ§  Knowledge Graph (KG) JSON

The KG JSON is the **single source of truth** for:

* **Schemas & tables** (e.g., `sales.orders`, `ref.regional_managers`).
* **Columns** (exact spelling/casing, including spaces like `"Order ID"` and slashes like `"State/Province"`).
* **Join hints** (which tables can be joined and how).

> **Important:** Agents must only use objects present in the KG.

**Default path:** `/mnt/data/store_graph.json` (override with `KG_JSON_PATH`).

---

## ğŸ§­ Router â€” Intent Classification

The router receives `{"message": "..."}` and chooses an agent:

| Intent           | Cues (examples)                                                                 | Agent             |
| ---------------- | ------------------------------------------------------------------------------- | ----------------- |
| data_access      | show, list, top, how many, trend, compare, report, breakdown byâ€¦, undeliveredâ€¦  | Data Access Agent |
| customer_success | create order, place order, update order, change shipping, cancel, accept return | Customer Success  |
| hr               | who managesâ€¦, escalate to LOB manager, draft/send escalation                    | HR Agent          |
| fallback         | ambiguous/mixed intents â†’ ask a brief clarifying question                       | Safe fallback     |

**Mixed intents** (e.g., *â€œshow top customers and cancel order Xâ€*): router splits into readâ†’write phases; the write phase still requires `confirm`.

---

## ğŸ” Data Access Agent (SQLâ€‘Only, KGâ€‘Driven)

**Goal:** Answer a question by producing **one** executable **PostgreSQL** statement (SELECT/WITH) that returns rows.

**Hard rules in brief**

* Use **schemaâ€‘qualified** table names **exactly** as in the KG (e.g., `sales.orders`).
* Quote mixedâ€‘case/special columns everywhere: `"Order ID"`, `"Customer Name"`, `"State/Province"`, `"Sales"`, `"Profit"`.
* When aggregating, include **all nonâ€‘aggregate selected columns** in `GROUP BY`.
* Return **one** fenced SQL block. **No DDL/DML. No multiâ€‘statements.**
* If Postgres errors, the agent selfâ€‘repairs once using the exact error and the KG.

**Light normalization (engineâ€‘side safeguards):**

* FROM/JOIN **basename remap** â†’ KGâ€™s FQNs (e.g., `synthetic_store.regional_managers` â†’ `ref.regional_managers`).
* Quote `t.Sales` â†’ `t."Sales"`; quote aggregate inners (e.g., `SUM("Sales")`).
* Quote bare known cols when unambiguous across involved tables.

**Example prompts**

* *â€œGive my top 10 Customers?â€* â†’ by default, top by `SUM("Sales")` if present (else by order count):

```sql
-- Top 10 customers by total sales (with profit and order count)
SELECT
  "Customer Name",
  SUM("Sales")  AS total_sales,
  SUM("Profit") AS total_profit,
  COUNT("Order ID") AS order_count
FROM sales.orders
GROUP BY "Customer Name"
ORDER BY total_sales DESC
LIMIT 10
```

* *â€œShow undelivered orders in California with regional manager names.â€* â†’ joins per KG; `WHERE "Ship Date" IS NULL`.

**API**:

```bash
curl -H "content-type: application/json" \
  -d '{"message":"Give my top 10 Customers?"}' \
  http://127.0.0.1:8000/chat
```

---

## ğŸ› ï¸ Customer Success Agent (Writes with Confirmation)

**Goal:** Place new orders, update undelivered orders, accept eligible returns, or cancel undelivered orders.

**Write safety flow**

1. User request â†’ agent composes the change **and** its SQL (INSERT/UPDATE/DELETE).
2. Agent replies with **WRITE BLOCKED** and a preview:

```
WRITE BLOCKED: will run:
UPDATE sales.orders
SET "Ship Mode" = 'Second Class'
WHERE "Order ID" = 'US-2020-135405' AND "Ship Date" IS NULL;

Reply with 'confirm' to proceed, or 'cancel' to abort.
```

3. User replies `confirm` â†’ agent executes the transaction, returns success (or error). Any other reply cancels.

**Operations:**

* **Create order** â€” INSERT into appropriate table(s).
* **Update** â€” UPDATE restricted to undelivered (`"Ship Date" IS NULL`) where applicable.
* **Accept return** â€” INSERT into returns table; enforce policy windows if defined in KG/policy.
* **Cancel** â€” DELETE or status update, depending on policy.

**Notes:**

* All writes are **transactional** (commit on success / rollback on error).
* Audit logging recommended for write previews and results.

---

## ğŸ‘” Human Resources Agent (Org Navigation & Escalations)

**Goal:** Resolve who to route/escalate to (e.g., LOB manager) using KG mapping tables and draft the message.

**Typical KG tables:**

* `ref.regional_managers` (Regional Manager, Regions)
* `ref.state_managers` (State/Province, Manager)
* `ref.segment_managers` (Segment, Manager)
* `ref.category_managers` (Category, Manager)
* `ref.customer_success_managers` (Regions, Manager)

**Flow example**

* User: *â€œIâ€™m the Texas state manager. Escalate shipping delays to West LOB manager and include top 3 undelivered orders this week.â€*
* HR agent:

  1. Resolves roles/recipients via KG tables.
  2. Calls Data Access Agent to fetch the top 3 undelivered orders.
  3. Drafts a clear escalation email with context + asks; returns the draft (and optionally sends it via your notifier).

---

## âš™ï¸ Setup & Configuration

**Python**: 3.10+

**Env vars**

| Variable       | Purpose                                     | Default                      |
| -------------- | ------------------------------------------- | ---------------------------- |
| `KG_JSON_PATH` | Path to Knowledge Graph JSON                | `/mnt/data/store_graph.json` |
| DB envs        | Used by `query/federation.py` (PG URL etc.) | see your engine wiring       |
| Gemini creds   | Used by `agno.models.google.Gemini`         | per your Agno/Gemini setup   |

**Install & run**

```bash
pip install -r requirements.txt
uvicorn app:app --reload --port 8000
```

**Test**

```bash
curl -H "content-type: application/json" \
  -d '{"message":"Give my top 10 Customers?"}' \
  http://127.0.0.1:8000/chat
```

---

## ğŸ” Safety & Guardrails

* **Data Access**: executes **only** SELECT/WITH single statements.
* **Customer Success**: never executes writes without an explicit `confirm` in the next user turn.
* **HR**: drafts by default; sending is optâ€‘in (wire your notifier and role checks).
* Agents are constrained to KG objects; no adâ€‘hoc tables/columns.

---

## ğŸ§ª Troubleshooting

* **Planner returned JSON**: Ensure your prompts require a **single fenced SQL block**; remove any instruction that says â€œReturn JSON.â€
* **Undefined column / quoting**: The agent must quote mixedâ€‘case/special identifiers. Light autoâ€‘quoting + one selfâ€‘repair attempt are built in.
* **ResourceClosedError**: Means a nonâ€‘result statement got produced; router/agent will ask for a single SELECT/WITH rewrite.
* **No rows**: Filters may be too strict; rephrase or broaden time/state constraints.

Collect the failed **SQL** and **error text** to improve prompts or KG.

---

## ğŸ§© Extending

* Add more agents (e.g., Inventory) â€” extend router intents and create an agent with tailored rules.
* RBAC â€” gate writes by user role before showing the write preview.
* Multiâ€‘engine reads â€” extend `run_sql()`/federation and teach the Data Access prompt to target other engines (e.g., Trino) when required.

---

## ğŸ™Œ Credits

Built with **FastAPI**, **Agno**, **Gemini**, **SQLAlchemy**, and **pandas** â€” plus your **Knowledge Graph JSON** as the source of truth.
