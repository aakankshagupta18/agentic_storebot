# StoreBot — Multi‑Agent Chatbot (Router + Data Access + Customer Success + HR)

A production‑ready, KG‑driven chatbot that routes user requests to specialized agents:

* **Data Access Agent** — turns questions into **one executable PostgreSQL query** using your Knowledge Graph (KG) JSON, executes it, and self‑repairs once on error.
* **Customer Success Agent** — places/updates/cancels orders and accepts eligible returns via **DB writes** with an explicit **confirm** gate.
* **Human Resources Agent** — navigates org hierarchy (regional/state/segment/category managers), drafts escalation emails, and (optionally) sends them via your notifier.
* **Router** — classifies messages into `data_access`, `customer_success`, `hr` (or a safe fallback) and orchestrates multi‑step flows (e.g., ask→confirm for writes).

> **Data source contract:** Agents may only use schemas/tables/columns defined by the **Knowledge Graph JSON**. No hallucinated objects.

---

## ✨ Features

* **Single‑statement SQL** (SELECT/WITH) generated by the LLM; no JSON plans required.
* **PostgreSQL only** (safe read path for Data Access; write path gated in Customer Success).
* **Light normalization** prevents trivial quoting/table‑basename issues.
* **Self‑repair:** On DB error, the agent uses the exact Postgres error to produce a corrected SQL once.
* **Write safety:** All writes are previewed and blocked until the user replies `confirm`.
* **Org-aware HR flows:** Resolves managers from KG tables; drafts crisp escalation emails.

---

## 🗂️ Repository Layout (key files)

```
agents/
  data_access.py        # SQL-only, KG-driven query agent (SELECT/WITH + self-repair)
  customer_success.py   # Write agent (INSERT/UPDATE/DELETE) with 'confirm' gate
  hr.py                 # HR agent: org lookup + escalation drafts (+optional send)
  router.py             # Intent routing, confirmation state, and orchestration

app.py                  # FastAPI app exposing POST /chat
query/
  federation.py         # run_sql(), summarize(), and DB engine wiring

graph/
  graph_store.py        # Loads KG and exposes table/column metadata + join hints

/mnt/data/store_graph.json  # Your Knowledge Graph JSON (path configurable)
```

---

## 🧠 Knowledge Graph (KG) JSON

The KG JSON is the **single source of truth** for:

* **Schemas & tables** (e.g., `sales.orders`, `ref.regional_managers`).
* **Columns** (exact spelling/casing, including spaces like `"Order ID"` and slashes like `"State/Province"`).
* **Join hints** (which tables can be joined and how).

> **Important:** Agents must only use objects present in the KG.

**Default path:** `/mnt/data/store_graph.json` (override with `KG_JSON_PATH`).

---

## 🧭 Router — Intent Classification

The router receives `{"message": "..."}` and chooses an agent:

| Intent           | Cues (examples)                                                                 | Agent             |
| ---------------- | ------------------------------------------------------------------------------- | ----------------- |
| data_access      | show, list, top, how many, trend, compare, report, breakdown by…, undelivered…  | Data Access Agent |
| customer_success | create order, place order, update order, change shipping, cancel, accept return | Customer Success  |
| hr               | who manages…, escalate to LOB manager, draft/send escalation                    | HR Agent          |
| fallback         | ambiguous/mixed intents → ask a brief clarifying question                       | Safe fallback     |

**Mixed intents** (e.g., *“show top customers and cancel order X”*): router splits into read→write phases; the write phase still requires `confirm`.

---

## 🔎 Data Access Agent (SQL‑Only, KG‑Driven)

**Goal:** Answer a question by producing **one** executable **PostgreSQL** statement (SELECT/WITH) that returns rows.

**Hard rules in brief**

* Use **schema‑qualified** table names **exactly** as in the KG (e.g., `sales.orders`).
* Quote mixed‑case/special columns everywhere: `"Order ID"`, `"Customer Name"`, `"State/Province"`, `"Sales"`, `"Profit"`.
* When aggregating, include **all non‑aggregate selected columns** in `GROUP BY`.
* Return **one** fenced SQL block. **No DDL/DML. No multi‑statements.**
* If Postgres errors, the agent self‑repairs once using the exact error and the KG.

**Light normalization (engine‑side safeguards):**

* FROM/JOIN **basename remap** → KG’s FQNs (e.g., `synthetic_store.regional_managers` → `ref.regional_managers`).
* Quote `t.Sales` → `t."Sales"`; quote aggregate inners (e.g., `SUM("Sales")`).
* Quote bare known cols when unambiguous across involved tables.

**Example prompts**

* *“Give my top 10 Customers?”* → by default, top by `SUM("Sales")` if present (else by order count):

```sql
-- Top 10 customers by total sales (with profit and order count)
SELECT
  "Customer Name",
  SUM("Sales")  AS total_sales,
  SUM("Profit") AS total_profit,
  COUNT("Order ID") AS order_count
FROM sales.orders
GROUP BY "Customer Name"
ORDER BY total_sales DESC
LIMIT 10
```

* *“Show undelivered orders in California with regional manager names.”* → joins per KG; `WHERE "Ship Date" IS NULL`.

**API**:

```bash
curl -H "content-type: application/json" \
  -d '{"message":"Give my top 10 Customers?"}' \
  http://127.0.0.1:8000/chat
```

---

## 🛠️ Customer Success Agent (Writes with Confirmation)

**Goal:** Place new orders, update undelivered orders, accept eligible returns, or cancel undelivered orders.

**Write safety flow**

1. User request → agent composes the change **and** its SQL (INSERT/UPDATE/DELETE).
2. Agent replies with **WRITE BLOCKED** and a preview:

```
WRITE BLOCKED: will run:
UPDATE sales.orders
SET "Ship Mode" = 'Second Class'
WHERE "Order ID" = 'US-2020-135405' AND "Ship Date" IS NULL;

Reply with 'confirm' to proceed, or 'cancel' to abort.
```

3. User replies `confirm` → agent executes the transaction, returns success (or error). Any other reply cancels.

**Operations:**

* **Create order** — INSERT into appropriate table(s).
* **Update** — UPDATE restricted to undelivered (`"Ship Date" IS NULL`) where applicable.
* **Accept return** — INSERT into returns table; enforce policy windows if defined in KG/policy.
* **Cancel** — DELETE or status update, depending on policy.

**Notes:**

* All writes are **transactional** (commit on success / rollback on error).
* Audit logging recommended for write previews and results.

---

## 👔 Human Resources Agent (Org Navigation & Escalations)

**Goal:** Resolve who to route/escalate to (e.g., LOB manager) using KG mapping tables and draft the message.

**Typical KG tables:**

* `ref.regional_managers` (Regional Manager, Regions)
* `ref.state_managers` (State/Province, Manager)
* `ref.segment_managers` (Segment, Manager)
* `ref.category_managers` (Category, Manager)
* `ref.customer_success_managers` (Regions, Manager)

**Flow example**

* User: *“I’m the Texas state manager. Escalate shipping delays to West LOB manager and include top 3 undelivered orders this week.”*
* HR agent:

  1. Resolves roles/recipients via KG tables.
  2. Calls Data Access Agent to fetch the top 3 undelivered orders.
  3. Drafts a clear escalation email with context + asks; returns the draft (and optionally sends it via your notifier).

---

## ⚙️ Setup & Configuration

**Python**: 3.10+

**Env vars**

| Variable       | Purpose                                     | Default                      |
| -------------- | ------------------------------------------- | ---------------------------- |
| `KG_JSON_PATH` | Path to Knowledge Graph JSON                | `/mnt/data/store_graph.json` |
| DB envs        | Used by `query/federation.py` (PG URL etc.) | see your engine wiring       |
| Gemini creds   | Used by `agno.models.google.Gemini`         | per your Agno/Gemini setup   |

**Install & run**

```bash
pip install -r requirements.txt
uvicorn app:app --reload --port 8000
```

**Test**

```bash
curl -H "content-type: application/json" \
  -d '{"message":"Give my top 10 Customers?"}' \
  http://127.0.0.1:8000/chat
```

---

## 🔐 Safety & Guardrails

* **Data Access**: executes **only** SELECT/WITH single statements.
* **Customer Success**: never executes writes without an explicit `confirm` in the next user turn.
* **HR**: drafts by default; sending is opt‑in (wire your notifier and role checks).
* Agents are constrained to KG objects; no ad‑hoc tables/columns.

---

## 🧪 Troubleshooting

* **Planner returned JSON**: Ensure your prompts require a **single fenced SQL block**; remove any instruction that says “Return JSON.”
* **Undefined column / quoting**: The agent must quote mixed‑case/special identifiers. Light auto‑quoting + one self‑repair attempt are built in.
* **ResourceClosedError**: Means a non‑result statement got produced; router/agent will ask for a single SELECT/WITH rewrite.
* **No rows**: Filters may be too strict; rephrase or broaden time/state constraints.

Collect the failed **SQL** and **error text** to improve prompts or KG.

---

## 🧩 Extending

* Add more agents (e.g., Inventory) — extend router intents and create an agent with tailored rules.
* RBAC — gate writes by user role before showing the write preview.
* Multi‑engine reads — extend `run_sql()`/federation and teach the Data Access prompt to target other engines (e.g., Trino) when required.

---

## 🙌 Credits

Built with **FastAPI**, **Agno**, **Gemini**, **SQLAlchemy**, and **pandas** — plus your **Knowledge Graph JSON** as the source of truth.
